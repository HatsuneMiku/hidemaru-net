// 秀丸 v8.66 以上
// hmV8 1.475 以上
// (C) 2017 VSCode.life

#JS = loaddll(hidemarudir + @"\hmV8.dll" );
if (!#JS) {
    message "hmV8の導入が必要です";
    endmacro;
}

#_ = dllfuncw(#JS, "DoString", R"JS(
// ライブラリの読み込み
host.lib( clr, "HmJapanesePhoneticAnalyzer");

// バッファー用の基本インターフェイス
class IDataBuffer {
    constructor() {
        this._all_text = "";
        this._buffer_contains_ruby = false;
    }
    GetAllText() {
        return this._all_text;
    }
    AddTextOnly(src) {
        this._all_text += src;
    }
    AddTextWithRuby(src, ruby) {
        this._buffer_contains_ruby = true;
        this._all_text += this.GetAddRubyFormat(src, ruby);
    }
    GetAddRubyFormat(src, ruby) {
        return "Need Implements GetAddRubyFormat";
    }
    IsContainsRuby() {
        return this._buffer_contains_ruby == true;
    }
}

// 横にルビを振る用のバッファークラス
// GetAddRubyFormatをoverride
class YokoRubyDataBuffer extends IDataBuffer {
    GetAddRubyFormat(src, ruby) {
        return src + '(' + ruby + ')';
    }
}

// HTMLでルビを振る用のバッファークラス
// GetAddRubyFormatをoverride
class HtmlRubyDataBuffer extends IDataBuffer {
    GetAddRubyFormat(src, ruby) {
        return '<ruby><rb>' + src + '</rb><rp>(</rp><rt>' + ruby + '</rt><rp>)</rp></ruby>';
    }
}

// バッファーをMapに定義。キーは最終的にバッファー内容を秀丸マクロの変数へと書き込む際の変数名
let buffers = new Map();
buffers.set( '$buf_text_with_rubied', new YokoRubyDataBuffer() );
buffers.set( '$buf_html_with_rubied', new HtmlRubyDataBuffer() );


// 変換対象の文字列取得の定義。
// 今のところ「通常の方法での選択したテキスト」
function GetTargetText() {
    if ( hm.Macro.Var["selecting"] ) {
        return hm.Edit.SelectedText;
    }
    return "";
};

// アウトプット枠への文字列出力
function OutputPane(text) {
    hm.Macro.Var["$OutputPaneMessageText"] = text;
    hm.Macro.Eval( f => { /*
        #HMOP = loaddll(hidemarudir + @"\HmOutputPane.dll");
        #r = dllfunc(#HMOP, "Output", hidemaruhandle(0), $OutputPaneMessageText + "\r\n");
        freedll( #HMOP );
    */ } );
}

// メイン処理
function Main() {

    // 変換対象となるテキスト全体を得る
    let target_text = GetTargetText();

    // 無ければさすがに窓を出して警告。終わり
    if (target_text.length == 0) {
        hm.Macro.Eval( f => { /*
            message("文字列が選択されていません。");
        */ } );
        return;
    }

    // あまり長々とした文章を一気に変換することが出来ない(Windows APIの都合)
    // なので、普通に日本語書いていれば、このくらいの記号で分離すればよいだろう
    let split_list = [];
    let breakPointRegexp = /(.+?)([\s、。（）「」＜＞\<\>\|\+\-\(\)\[\]\.\,\!\?\'\"]|$)/g;
    while ((match_array = breakPointRegexp.exec(target_text)) != null) {

        // 通常の内容は、APIで分析する必要があるもの
        split_list.push({data:match_array[1], need_analyze:true });

        // 分離に使った最後の文字は、APIで分析する必要がないもの
        split_list.push({data:match_array[2], need_analyze:false});
    }

    // アナライザーのオブジェクト生成。
    let divider = new clr.HmJapanesePhoneticAnalyzer();

    // 事前にある程度分割しておいた文字列の各々で…
    for (let i=0; i<split_list.length; i++) {
        let target_text = split_list[i].data;

        // APIで分析する必要があるのであれば…
        if (split_list[i].need_analyze) {
            // 分析する。結果は「List<Windows.Globalization.JapanesePhoneme>」と同様のプロパティを持つもの。
            // 但し、DisplayTextは変換後全角データではなく、変換前のデータ、IsPhraseStartは「DisplayText」に漢字が含まれているかどうかのフラグ
            // というように少し意味を変えている。
            let record_list = divider.GetJapanesePhoneticAnalyzeDataList(target_text);
            // 結果をバッファーへと足しこみ
            AddToBufferJapanesePhoneticAnalyzeData(record_list);

        // 分析する必要が無いのであれば、こちらもバッファーへと単純足しこみ
        } else {
            buffers.forEach(
                (buffer) => buffer.AddTextOnly(target_text)
            );
        }
    }

    AssignToHidemaruVarable();
}

// 変換対象の文字列取得の定義。
function AddToBufferJapanesePhoneticAnalyzeData(record_list) {

    // 分かち書きされた各々のレコードやルビに対して…
    for(let record of record_list) {

        // 漢字に対するルビである
        if (record.IsPhraseStart) {
            // 各バッファーは自身のルビ振りのフォーマット変形を利用しながら、文字列を連結
            buffers.forEach( (buffer) => buffer.AddTextWithRuby(record.DisplayText, record.YomiText) );
        } else {
            // 各バッファーは普通に文字列を連結
            buffers.forEach( (buffer) => buffer.AddTextOnly(record.DisplayText) );
        }
    }
}

function AssignToHidemaruVarable() {

    // で、結局最終的に秀丸の新ページとして出力するべきなの？
    let is_buf_contains_ruby = false;

    // ルビを持っているバッファがあるのであれば、出すべき 
    buffers.forEach( (buffer) => { if (buffer.IsContainsRuby()) is_buf_contains_ruby = true; } );

	// 全バッファーにルビは含まれていない。アウトプット枠に情報を出すだけで終わり
    if (!is_buf_contains_ruby) {
        OutputPane("ルビ振りに対象となる文字列はありません");
        return;
    }

    // 全てのバッファーを「対応する秀丸マクロ変数」へと書き込み
    buffers.forEach(
        (buffer, name) => hm.Macro.Var[name] = buffer.GetAllText() 
    );

    // hmV8 1.475以上にしたいので、1:0を手書き。1.498以降であれば、Boolean値をそのまま代入できるのだが…
    hm.Macro.Var['#is_buf_contains_ruby'] = is_buf_contains_ruby ? 1 : 0;
}

Main();


)JS"
);

freedll(#JS);

// ルビ振りデータが存在するのであれば
if (#is_buf_contains_ruby) {

	// 新規ファイル作成
    newfile;
	// 横にルビを振る方
    insert $buf_text_with_rubied;

	// 新規ファイル作成
    newfile;
	// HTMLタグを付ける方
    insert $buf_html_with_rubied;
}
